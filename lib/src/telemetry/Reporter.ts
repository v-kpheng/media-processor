import axios, { AxiosInstance, AxiosResponse, AxiosRequestConfig } from 'axios';
import { Optional } from 'typescript-optional';
import { version } from '../utils/package-json';

export type VonageSourceType = 'automation' | 'test' | 'vbc' | 'video' | 'voice';

/**
 * Specifies the addional information being sent with the telemetry collected by the library.
 */
 export type VonageMetadata = {
   /**
    * Type of source using the library.
    */
  sourceType: VonageSourceType,
   /**
    * Some string identifier identifying the application using the library.
    */
  appId: string

  /**
   * The proxy URL to route all internet traffic generated by this library.
   */
  proxyUrl?: string
}

declare global {
  var _vonageMediaProcessorMetadata: VonageMetadata
}

/**
 * Sets some metadata for telemetry.
 *
 * @param metadata  Specifies the addional information being sent with the telemetry collected by the library.
 *                  If metadata is either undefined or not set the library will not collect/send any telemetry.
 *
 * @example
 *
 * ```ts
 *   const metadata: VonageMetadata = {
 *     appId: 'vonage-media-processor-example',
 *     sourceType: 'test'
 *   };
 *   setVonageMetadata(metadata);
 *   let metadataGet: VonageMetadata = getVonageMetadata();
 * ```
 */
export function setVonageMetadata(metadata: VonageMetadata): void {
  globalThis._vonageMediaProcessorMetadata = metadata
}

export function getVonageMetadata(): VonageMetadata{
  return globalThis._vonageMediaProcessorMetadata
}

interface Report {
  action: Optional<string>;
  applicationId: Optional<string>;
  timestamp: number;
  fps: Optional<number>;
  framesTransformed: Optional<number>;
  guid: Optional<string>;
  highestFrameTransformCpu: Optional<number>; // TODO(jaoo)
  message: Optional<string>;
  source: Optional<string>;
  transformedFps: Optional<number>;
  transformerType: Optional<string>;
  variation: Optional<string>;
  videoHeight: Optional<number>;
  videoWidth: Optional<number>;
  version: string;
  error: Optional<string>;
  proxyUrl: Optional<string>;
}

class ReportBuilder {
  private readonly _report: Report;

  constructor() {
    const metadata: VonageMetadata = getVonageMetadata()
    this._report = {
      action: Optional.empty<string>(),
      applicationId: Optional.ofNullable((metadata !== undefined && metadata != null) ? metadata.appId : null),
      timestamp: Date.now(),
      fps: Optional.empty<number>(),
      framesTransformed: Optional.empty<number>(),
      guid: Optional.empty<string>(),
      highestFrameTransformCpu: Optional.empty<number>(),
      message: Optional.empty<string>(),
      source: Optional.ofNullable((metadata !== undefined && metadata != null) ? metadata.sourceType : null),
      transformedFps: Optional.empty<number>(),
      transformerType: Optional.empty<string>(),
      variation: Optional.empty<string>(),
      videoHeight: Optional.empty<number>(),
      videoWidth: Optional.empty<number>(),
      version: version,
      error: Optional.empty<string>(),
      proxyUrl: Optional.ofNullable((metadata !== undefined && metadata != null) ? metadata.proxyUrl : null)
    };
  }

  action(action: string) {
    this._report.action = Optional.ofNullable(action);
    return this;
  }

  framesTransformed(framesTransformed: number) {
    this._report.framesTransformed = Optional.ofNullable(framesTransformed);
    return this;
  }

  fps(fps: number) {
    this._report.fps = Optional.ofNullable(fps);
    return this;
  }

  guid(guid: string) {
    this._report.guid = Optional.ofNullable(guid);
    return this;
  }

  message(message: string) {
    this._report.message = Optional.ofNullable(message);
    return this;
  }

  transformedFps(transformedFps: number) {
    this._report.transformedFps = Optional.ofNullable(transformedFps);
    return this;
  }

  transformerType(transformerType: string) {
    this._report.transformerType = Optional.ofNullable(transformerType);
    return this;
  }

  variation(variation: string) {
    this._report.variation = Optional.ofNullable(variation);
    return this;
  }

  videoHeight(videoHeight: number) {
    this._report.videoHeight = Optional.ofNullable(videoHeight);
    return this;
  }

  videoWidth(videoWidth: number) {
    this._report.videoWidth = Optional.ofNullable(videoWidth);
    return this;
  }

  error(error: string){
    this._report.error = Optional.ofNullable(error)
    return this
  }

  build(): Report{
    return this._report
  }
}

const serializeReport = (report: Report): string => {
  return JSON.stringify(report, (key, value) => {
    if (value !== null) return value
  });
}

class Reporter {
    static report(report: Report): Promise<any>{
        return new Promise<any>((resolve, reject) => {
          if(report.applicationId.isEmpty() || report.source.isEmpty()){
            resolve('success')
            return
          }

          let axiosInstance: AxiosInstance = axios.create()
          let config: AxiosRequestConfig = {
              timeout: 10000,
              timeoutErrorMessage: "Request timeout",
              headers: {
                    'Content-Type': 'application/json'
              }
          }
          
          let telemetryServerUrl: string = 'hlg.tokbox.com/prod/logging/vcp_webrtc'
          if(!report.proxyUrl.isEmpty()){
            let proxy: string
            if(report.proxyUrl.get().slice(report.proxyUrl.get().length - 1) !== '/'){
              proxy = report.proxyUrl.get() + '/'
            } else {
              proxy = report.proxyUrl.get()
            }
            telemetryServerUrl = proxy + telemetryServerUrl
          } else {
            telemetryServerUrl = 'https://' + telemetryServerUrl
          }
          axiosInstance.post(telemetryServerUrl, serializeReport(report), config)
          .then((res: AxiosResponse) => {
              console.log(res);
              resolve('success')
          })
          .catch(e => {
              console.log(e);
              reject(e)
          })
      });
    }
}

export {
  Report,
  ReportBuilder,
  Reporter
}
